package main

import (
	"fmt"
	"os"
	"sync"
	"time"
)

func main() {
	wg := sync.WaitGroup{}
	var a int
	/* Выбрать вариант остановки горутины(1 - это остановка через канал, который у нас специально только для этого,
	2 - остановка через канал, который мы используем, как только считывать будет нечего, записываем с горутины в него значение)
	*/
	fmt.Println("Выберите способ остановки горутины(1 или 2)")
	fmt.Fscan(os.Stdin, &a)
	ch := make(chan struct{})
	defer close(ch)
	wg.Add(1)
	if a == 1 {

		go func() {
			for {
				select {
				case <-ch:
					fmt.Println("При прочтении из канала завершаем функцию с помощью return")
					wg.Done()
					return
				default:
					fmt.Println("Первая горутина работает")
				}
			}
		}()
		// После секунды пишем в канал, при прочтении из него горутина завершится и мы продолжим работу
		time.Sleep(1 * time.Second)
		ch <- struct{}{}
		wg.Wait()
		fmt.Println("Дождались завершения выбранной горутины")

	} else if a == 2 {

		go func() {
			for {
				select {
				case <-ch:
					fmt.Println("Вторая горутина работает")
				case ch <- struct{}{}:
					fmt.Println("Даем сигнал в канал из горутины, после чего канал закрывается")
					return
				}
			}
		}()
		/*
			Пишем в канал, при прочтении из него, ждем когда горутина запишет в этот же канал значение, только после этого
			горутина завершится, а мы узнаем, что ее уже нет
		*/
		for i := 0; i < 10; i++ {
			ch <- struct{}{}
		}
		<-ch
		fmt.Println("Дождались завершения выбранной горутины")
	} else {
		fmt.Println("Ввели несуществующий вариант")
	}
}
